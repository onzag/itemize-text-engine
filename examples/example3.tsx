import React, { useCallback, useContext, useState } from "react";
import ReactDOM from "react-dom";
import { deserialize } from "../serializer";
import { IFeatureSupportOptions, sanitize } from "../sanitizer";
import { renderTemplateDynamically } from "../renderer";
import { TemplateArgs } from "../serializer/template-args";
import { IUIHandlerProps } from "../serializer/base";

const featureSupport: IFeatureSupportOptions = {
  supportedContainers: [],
  supportedCustoms: [],
  supportedRichClasses: [],
  supportedTables: [],
  supportsContainers: true,
  supportsCustom: true,
  supportsCustomStyles: true,
  supportsExternalLinks: true,
  supportsFiles: true,
  supportsFilesAccept: null,
  supportsImages: true,
  supportsImagesAccept: null,
  supportsLinks: true,
  supportsLists: true,
  supportsQuote: true,
  supportsRichClasses: true,
  supportsTables: true,
  // notice this being true
  supportsTemplating: true,
  supportsTitle: true,
  supportsVideos: true,
};

// UI Handlers allow for customizing behaviours, and while it may seem similar to using data-html
// ui handlers allow to set up arguments and are meant to be edited in the rich text editor in a WYSIWYG fashion
// they are insertable widgets, fully compatible with templating, this is what you use for interactive content
// generated by content producers, any component can be UI Handled
const TEXT_FROM_SERVER_1 = '<p>please input your name <span class="inline" data-ui-handler="inputField" data-placeholder="here">input field</span></p>';

const sanitized1 = sanitize({
  fileResolver: null,
}, featureSupport, TEXT_FROM_SERVER_1);

const textTree1 = deserialize(sanitized1);

function InputUIHandler(props: IUIHandlerProps) {
  const [value, setValue] = useState("");

  const setValueCb = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value);
  }, []);

  return (
    <input
      placeholder={props.args.placeholder}
      value={value}
      onChange={setValueCb}
      className={props.className}
      style={props.style}
    />
  );
}

const rendered1 = renderTemplateDynamically(textTree1, new TemplateArgs(
  {
    inputField: InputUIHandler,
  }
));

// UI Handlers can also have children, which can also in turn be UI Handled
// note how we add a random paragraph which we will normalize later
// by adding context rules
const TEXT_FROM_SERVER_2 = '<div data-ui-handler="radioGroup"><p>invalid</p><p data-ui-handler="radioField" data-value="1">option 1</p><p data-ui-handler="radioField" data-value="2">option 2</p><p data-ui-handler="radioField" data-value="3">option 3</p></div>';

const sanitized2 = sanitize({
  fileResolver: null,
}, featureSupport, TEXT_FROM_SERVER_2);

// with this deserialization we ensure that our UI Handlers are normalized properly
// and our <p>invalid</p> does not appear in
const textTree2 = deserialize(sanitized2, null, {
  useContextRulesOf: {
    label: "root",
    type: "context",
    properties: {
      radioGroup: {
        type: "ui-handler",
        label: "radio group",
        // ensure that all radio groups only contain radio fields
        allowsChildren: (c) => {
          return (c.uiHandler === "radioField");
        },
      },
      radioField: {
        type: "ui-handler",
        label: "radio field",
        // ensure that all radio fields are inside a radio group
        allowsParent: (c) => {
          return (c.type === "container" && c.uiHandler === "radioGroup");
        },
      }
    }
  }
});

const RadioContext = React.createContext<{ value: string; onChange: (value: string) => void }>(null)

function RadioGroupUIHandler(props: IUIHandlerProps) {
  const [value, onChange] = useState(null as string);

  return (
    <RadioContext.Provider value={{ value, onChange }}>
      <div style={{ border: "solid 1px red" }} className={props.className}>
        {props.children}
      </div>
    </RadioContext.Provider>
  );
}

function RadioFieldUIHandler(props: IUIHandlerProps) {
  const contextV = useContext(RadioContext);
  return (
    <div
      style={{ border: "solid 1px " + (contextV.value === props.args.value ? "green" : "#ccc") }}
      onClick={contextV.onChange.bind(null, props.args.value)}
      className={props.className}
    >
      {props.children}
    </div>
  );
}

const rendered2 = renderTemplateDynamically(textTree2, new TemplateArgs(
  {
    radioField: RadioFieldUIHandler,
    radioGroup: RadioGroupUIHandler,
  }
));

// UI Handlers can also play with all the other features defined before, however they need to be specified manually
// for example the styleActive and styleHover properties need to be set manually since the component
// is ui handled by itself, even props.events are included

function Example() {
  return (
    <div>
      <h1>Using UI Handlers</h1>

      <section>
        <h4>
          Basic UI Handler to have input fields
        </h4>
        <div>
          Original HTML (also sanitized):
        </div>
        <code>{TEXT_FROM_SERVER_1}</code>
        <div>
          rendered template dinamically (react component)
        </div>
        <div className="rich-text" style={{ padding: "10px", border: "solid 1px #ccc" }}>{rendered1}</div>
      </section>

      <section>
        <h4>
          Basic UI Handler that contains UI handlers and contains content within the handler
        </h4>
        <div>
          Original HTML (also sanitized):
        </div>
        <code>{TEXT_FROM_SERVER_2}</code>
        <div>
          rendered template dinamically (react component)
        </div>
        <div className="rich-text" style={{ padding: "10px", border: "solid 1px #ccc" }}>{rendered2}</div>
      </section>
    </div>
  );
}

ReactDOM.render(<Example />, document.querySelector("#app"));